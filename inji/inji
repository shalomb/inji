#!/usr/bin/env python3

# -*- coding: utf-8 -*-

# NAME

# inji - Render jina2 templates to stdout

from __future__ import print_function, with_statement

import argparse
import atexit
import fnmatch
from jinja2 import DebugUndefined, StrictUndefined, Undefined, make_logging_undefined
from jinja2 import Environment, FileSystemLoader
from jinja2.exceptions import TemplateNotFound, UndefinedError
import json
import locale
import logging
import os
from os.path import abspath, basename, dirname, exists, expandvars, isdir, isfile, join
import re
import shutil
import sys
import tempfile
import yaml

def render_template(
    template,
    in_vars,
    strict_mode_behaviour
  ):

  m = strict_mode_behaviour
  if   m in ['strict', 'StrictUndefined']:
    Handler = StrictUndefined
  elif m in ['empty',  'Undefined']:
    Handler = Undefined
  elif m in ['keep',   'DebugUndefined']:
    Handler = DebugUndefined

  # Setup debug logging on STDERR to have the jinja2 engine emit
  # its activities
  root = logging.getLogger(template)
  root.setLevel(logging.DEBUG)
  handler = logging.StreamHandler(sys.stderr)
  logformat = '%(name)s %(levelname)s: %(message)s'
  formatter = logging.Formatter(logformat)
  handler.setFormatter(formatter)
  root.addHandler(handler)

  UndefinedHandler = make_logging_undefined( logger=root, base=Handler )

  # This is contra the design philosophy of jinja where templates are part of
  # bigger projects and includes are possible relative to the target template.
  # But we are a tool that renders (simple) templates and while we do not
  # preclude complex use cases, we assume the target is the "master" template
  # and any includes, etc it uses are relative to where it resides (not the
  # current directory of the process).
  rootdir = dirname(template)

  j2_env = Environment( loader=FileSystemLoader(rootdir),
                        undefined=UndefinedHandler,
                        trim_blocks=True )

  try:
    template = basename(template)
    yield j2_env.get_template(template).render(in_vars)
  except UndefinedError as e:
    raise UndefinedError( "variable {} in template '{}'".format(
            str(e), template) ) from e


def json_parse(string):
  """ Parse a JSON string into a dictionary """
  try:
    return json.loads(string)
  except Exception as e:
    msg = 'Error parsing JSON config: {}'.format(str(e))
    print(msg, file=sys.stderr)
    raise TypeError(msg)

def kv_parse(string):
  """ Parse a string of the form foo=bar into a dictionary """
  try:
    key, val = string.split('=', 1)
    if key is None or key == '':
      raise TypeError('Empty key')
  except Exception as e:
    err = "Invalid key found parsing KV string '{}': {}".format(string, str(e))
    print(err, file=sys.stderr)
    raise
  return { key: val }

def read_in_vars(yaml_file):
  yaml_file = yaml_file.__str__()
  with open(yaml_file, 'r') as f:
    try:
      in_vars = yaml.load(f, Loader=yaml.SafeLoader)
      if in_vars is None:
        raise TypeError("'{}' contains no data".format(file))
    except TypeError as exc:
      raise exc
  return in_vars

def recursive_iglob(rootdir='.', pattern='*'):
  for root, dirnames, filenames in os.walk(rootdir):
    for filename in fnmatch.filter(filenames, pattern):
      yield os.path.join(root, filename)

def path(fspath, type='file'):
  """
  Checks if a filesystem path exists with the correct type
  """

  fspath = abspath(expandvars(str(fspath)))
  msg = None
  prefix = "path '{0}'".format(fspath)

  if not exists(fspath):
    msg = "{0} does not exist".format(prefix)

  if type == 'file' and isdir(fspath):
    msg = "{0} is not a file".format(prefix)

  if msg is not None:
    raise argparse.ArgumentTypeError(msg)

  return fspath

def file_or_stdin(file):
  # /dev/stdin is a special case allowing bash (and other shells?) to name stdin
  # as a file. While python should have no problem reading from it, we actually
  # read template relative to the template's basedir and /dev has no templates.
  if file == '-' or file == '/dev/stdin':
    return '-'
  return path(file)

def cli_args():
  parser = argparse.ArgumentParser(description='inji - jinja template renderer')
  required = parser.add_argument_group('required arguments')

  required.add_argument('-t', '-f', '--template',
    action = 'store',  required=False, type=file_or_stdin,
    dest='template', default='-',
    help='/path/to/template.j2 (defaults to -)'
  )

  parser.add_argument('-j', '--json-config', '-c',
    action = 'store', required=False,
    type=lambda x: json_parse(x),
    dest='json_string',
    help="-c '{ \"foo\": \"bar\", \"fred\": \"wilma\" }'"
  )

  parser.add_argument('-k', '--kv-config', '-d',
    action = 'store', required=False,
    type=lambda x: kv_parse(x),
    dest='kv_pair',
    help='-d foo=bar -d fred=wilma'
  )

  parser.add_argument('-o', '--overlay-dir',
    action = 'append', required=False, type=lambda p, t='dir': path(p, t),
    dest='overlay_dir', default=[],
    help='/path/to/overlay/'
  )

  parser.add_argument('-v', '-p', '--vars-file', '--vars',
    action = 'append', required=False, type=lambda p, t='file': path(p, t),
    dest='vars_file', default=[],
    help='/path/to/vars.yaml'
  )

  parser.add_argument('--strict-mode', '-s',
    action = 'store', required=False, type=str,
    dest='strict_mode', default='strict',
    choices=[ 'strict', 'empty', 'keep',
              'StrictUndefined', 'Undefined', 'DebugUndefined' ],
    help='Refer to http://jinja.pocoo.org/docs/2.10/api/#undefined-types'
  )

  return parser.parse_args()


if __name__ == '__main__':

  args = cli_args()

  # this holds all the possible vars files we are told about or imply
  vars_files = []

  # in_vars in the local configuration files - p5
  vars_files += fnmatch.filter(os.listdir('.'), "*inji.y*ml")

  # in_vars in the overlay directories - p4
  for d in args.overlay_dir:
    files = list(recursive_iglob(d, '*.y*ml'))
    if len(files):
      loc = locale.getlocale()
      locale.setlocale(locale.LC_ALL, 'C') # Using LC_ALL=C POSIX locale
      files.sort()                         # We force the sort collation of files
      locale.setlocale(locale.LC_ALL, loc) # And then reset it back
      vars_files += files

  # in_vars from named vars files - p3
  vars_files += args.vars_file

  # This will hold the final vars dict merged from various available sources
  in_vars = {}
  for file in vars_files:
    in_vars.update(read_in_vars(file))

  # in_vars from environment variables - p2
  in_vars.update(os.environ)

  # in_vars at the command line (either JSON or KV type) - p1
  if args.json_string:
    in_vars.update(args.json_string)

  if args.kv_pair:
    in_vars.update(args.kv_pair)

  if args.template == '-':
    # Template passed in via stdin. Create template as a tempfile and use it
    # instead but since includes are possible (though not likely), we have to do
    # this in an isolated tmpdir container to prevent inadvertent reading of
    # includes not meant to be read.
    tmpdir = tempfile.mkdtemp()
    atexit.register(shutil.rmtree, tmpdir)

    _, tmpfile = tempfile.mkstemp(prefix='stdin-', dir=tmpdir, text=True)
    atexit.register(os.remove, tmpfile)

    with open(tmpfile, "a+") as f:
      f.write(sys.stdin.read())
    args.template = tmpfile

  for block in render_template( args.template,
                                in_vars,
                                args.strict_mode ):
    print(block)

